package com.ksh.mockup.service;

import com.ksh.mockup.entity.ClientResponse;
import com.ksh.mockup.entity.MyHttpHeader;
import com.ksh.mockup.entity.MyHttpRequest;
import com.ksh.mockup.entity.MyHttpResponse;
import com.ksh.mockup.repository.ClientResponseRepository;
import com.ksh.mockup.repository.VuePage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.*;
import org.springframework.stereotype.Service;

import java.io.*;
import java.net.*;
import java.time.LocalDateTime;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
public class ServerService {

    private static final Logger log = LoggerFactory.getLogger(ServerService.class);

    private static final int MalformedURLException = 501;
    private static final int SocketTimeoutException = 502;
    private static final int IOException = 503;
    private static final int NullPointerException = 504;

    //This means to get the bean call clientResponseRepository
    //which is auto-generated by Spring, we will use it to handle the data
    @Autowired
    private ClientResponseRepository clientResponseRepository;


    public MyHttpResponse httpRequest(MyHttpRequest mcHttpRequest)  throws Exception{

        HttpURLConnection conn = null;

        MyHttpResponse mcHttpResponse=null;
        DataOutputStream wr = null;
        BufferedReader in = null;
        try{
            //creating a request with a header, a body to  server
            URL myURL = new URL(mcHttpRequest.getTargetUrl());
            conn = (HttpURLConnection)myURL.openConnection();

            //add reuqest header
            conn.setRequestMethod(mcHttpRequest.getMethod());

            //InputStream으로 응답 헤더와 메시지를 읽겠다 라는 옵션 동의
            conn.setDoInput(true);

            //OutputStream으로  해당 메소드 데이터를 넘겨주겠다라는 옵션 동의
            conn.setDoOutput(true);

            //Header
            conn.addRequestProperty("Content-Type","application/x-www-form-urlencoded");
            conn.addRequestProperty("Accept-Charset","UTF-8");
            for(MyHttpHeader myHttpHeader : mcHttpRequest.getHeaders()){
                conn.addRequestProperty(myHttpHeader.getName() , myHttpHeader.getValue());
            }
            conn.setConnectTimeout(1000);
            conn.setReadTimeout(2000);

            wr = new DataOutputStream(conn.getOutputStream());
            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(wr,"UTF-8"));
            byte[] b_body = URLEncoder.encode(mcHttpRequest.getBody(),"UTF-8").getBytes();
            wr.write(b_body);

            //Stream Buffer를 비워준다.
            writer.flush();

            //Stream를 닫는다.
            writer.close();

            //Response 처리
            log.info("##### Response Code #####");
            log.info("CODE : " + conn.getResponseCode());

            //이렇게 하는 이유는... key값이 널이 포함되어 있기 때문
            log.info("##### Response Header #####");
            Map<String, String> responseHeader = new HashMap<>();
            for (Map.Entry<String, List<String>> entry : conn.getHeaderFields().entrySet()) {
                if(entry.getKey()  != null) {
                    log.info(entry.getKey() + " : " + entry.getValue());
                    responseHeader.put(entry.getKey(),entry.getValue().toString());
                } else{
                    log.info( "null : " + entry.getValue());
                    responseHeader.put("null",entry.getValue().toString());
                }
            }
            log.info("##### Response Body #####");
            if (200 <= conn.getResponseCode() && conn.getResponseCode() <= 299) {
                in = new BufferedReader(new InputStreamReader(conn.getInputStream(),"UTF-8"), conn.getContentLength());
                String inputLine;
                StringBuilder sbBody = new StringBuilder();
                while ((inputLine = in.readLine()) != null) {
                    log.info(inputLine);
                    sbBody.append(inputLine);
                }
                in.close();
                mcHttpResponse = new MyHttpResponse(conn.getResponseCode(),responseHeader,sbBody.toString());
            } else {
                mcHttpResponse = new MyHttpResponse(NullPointerException,responseHeader,null);
            }

        }catch(NullPointerException e) {
            log.error(e.getMessage());
            mcHttpResponse = new MyHttpResponse(NullPointerException,null,e.getMessage());
        }catch(SocketTimeoutException e) {
            log.error(e.getMessage());
            mcHttpResponse = new MyHttpResponse(SocketTimeoutException,null,e.getMessage());
        }catch (MalformedURLException e){
            log.error(e.getMessage());
            mcHttpResponse = new MyHttpResponse(MalformedURLException,null,e.getMessage());
        }catch (IOException e){
            log.error(e.getMessage());
            mcHttpResponse = new MyHttpResponse(IOException,null,e.getMessage());
        }finally {
//            try { in.close(); } catch (IOException e) { e.printStackTrace(); }
  //          try { wr.close(); } catch (IOException e) { e.printStackTrace(); }
        }
        return mcHttpResponse;
    }

    public Iterable<ClientResponse> getClientResponseList(Pageable pageable) {
        String url ="";
        Iterable<ClientResponse> source = clientResponseRepository.findAll(pageable);
        Page p = clientResponseRepository.findAll(pageable);
        VuePage<ClientResponse> vuepage = new VuePage(p.getContent(), pageable, p.getTotalElements(), url);

        // This returns a JSON or XML with the users
        return vuepage;
    }

    public ResponseEntity<String> getServiceResult(RequestEntity<String> requestEntity){
        HttpMethod method  = requestEntity.getMethod();
        HttpHeaders headers = requestEntity.getHeaders();

        String dstMrn ="";
        String srcMrn ="";
        String uuid ="";
        String AccessToken ="";
        String HexSignedData ="";
        String payload ="";
        LocalDateTime now = LocalDateTime.now();;

        if(headers.get("dstMrn") != null)
            dstMrn = headers.get("dstMrn").toString();
        if(headers.get("srcMrn") != null)
            srcMrn = headers.get("srcMrn").toString();
        if(headers.get("uuid") != null)
            uuid = headers.get("uuid").toString();
        if(headers.get("dstMrn") != null)
            dstMrn = headers.get("dstMrn").toString();
        if(headers.get("AccessToken") != null)
            AccessToken = headers.get("AccessToken").toString();
        if(headers.get("HexSignedData") != null)
            HexSignedData = headers.get("HexSignedData").toString();
        if(requestEntity.getBody() != null) {
            try {
                payload = URLDecoder.decode(requestEntity.getBody(),"UTF-8");
                if(payload.indexOf("=") > -1){
                    payload = payload.substring(0,payload.length()-1);
                }
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
        }

        ClientResponse client = new ClientResponse();
        client.setMethod(method.toString());
        client.setDstMrn(dstMrn);
        client.setSrcMrn(srcMrn);
        client.setUuid(uuid);
        client.setAccessToken(AccessToken);
        client.setHexSignedData(HexSignedData);
        client.setPayload(payload);
        client.setRegDate(now);
        clientResponseRepository.save(client);

        log.info("--------------------------------------------------------------------------");
        log.info(client.toString());
        log.info("--------------------------------------------------------------------------");


        //실제클라이언트에서는 dstMrn, srcMrn 등의 값을 리턴하진 않으므로 Header에는 빈값으로 넣자.
        HttpHeaders responeHeaders = new HttpHeaders();
        responeHeaders.add("Content-Type","text/plain;charset=UTF-8");

        ResponseEntity<String> responseEntity = new ResponseEntity<>("OK",responeHeaders, HttpStatus.OK);

        return responseEntity;
    }
}
