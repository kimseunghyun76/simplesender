package com.ksh.mockup.controller;

import com.ksh.mockup.entity.ClientResponse;
import com.ksh.mockup.entity.MyFile;
import com.ksh.mockup.entity.MyHttpRequest;
import com.ksh.mockup.entity.MyHttpResponse;
import com.ksh.mockup.repository.ClientResponseRepository;
import com.ksh.mockup.repository.VuePage;
import com.ksh.mockup.repository.VuePageable;
import com.ksh.mockup.service.FileService;
import com.ksh.mockup.service.ServerService;
import com.mashape.unirest.http.Headers;
import com.mashape.unirest.http.HttpResponse;
import com.mashape.unirest.http.Unirest;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.support.ResourcePatternResolver;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Sort;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.UnsupportedEncodingException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;



@RestController
public class McMockupController {

    private static final Logger log = LoggerFactory.getLogger(McMockupController.class);

    @Autowired
    ResourcePatternResolver resourceResolver;

    @Autowired
    FileService fileService;

    @Autowired
    ServerService serverService;


    @Value("${server.address}")
    private String serverAddress;

    @Value("${server.port}")
    private String serverPort;


    @RequestMapping("/")
    public ResponseEntity<String> getServiceResult(RequestEntity<String> requestEntity) throws UnsupportedEncodingException {
        return serverService.getServiceResult(requestEntity);
    }

    //This means to get the bean call clientResponseRepository
    //which is auto-generated by Spring, we will use it to handle the data
    @Autowired
    private ClientResponseRepository clientResponseRepository;



    @CrossOrigin(maxAge = 3600)
    @RequestMapping(path="/clientResponseList")
    @ResponseBody()
    public Iterable<ClientResponse> getClientResponseList(
            @RequestParam(value = "page", defaultValue = "1") int page,
            @RequestParam(value = "per_page", defaultValue = "15") int per_page,
            @RequestParam(value = "sort", required=false) String sort,
            @RequestParam(value = "filter", required=false) String filter) {

        String url ="http://" + serverAddress + ":" +serverPort +"/clientResponseList";
        Sort s = null;
        String properties = "";
        String direction = "";

        if(sort != null && sort.lastIndexOf("|") >  -1){
            properties = sort.split("\\|")[0];
            direction = sort.split("\\|")[1];
            log.info(properties);
            log.info(direction);
            if(direction.equals("desc")){
                s = new Sort(Sort.Direction.DESC,properties);
            }else{
                s = new Sort(Sort.Direction.ASC,properties);
            }
        }
        //VUE에서는 0 부터 시작하지 않고, 1부터 시작한다.
        // 따라서 page 값에서 -1 을 해서 추가해야한다.
        page= page-1;
        VuePageable pageable = new VuePageable(page, per_page, s);
        Page p = null;

        JSONParser parser = new JSONParser();
        String findFilter = "";
        String searchText = "";
        String searchName= "";
        String startDate = "";
        String endDate = "";
        LocalDateTime startDateTime=LocalDateTime.now();
        LocalDateTime endDateTime=LocalDateTime.now();

        if(filter != null){
            try{
                Object obj = parser.parse("["+filter+"]");
                JSONArray array = (JSONArray)obj;
                JSONObject filterObj = (JSONObject)array.get(0);
                if(filterObj.get("filter") != null) {
                    JSONObject searchObj =  (JSONObject)filterObj.get("filter");
                    findFilter = filterObj.get("filter").toString();
                    searchName = searchObj.get("searchName").toString();
                    searchText = searchObj.get("searchText").toString();
                    startDate = searchObj.get("startDate").toString() + " 00:00";
                    endDate = searchObj.get("endDate").toString()+ " 23:59";

                    // 날짜넘어온것을 이제부터 넘겨봅시다요.
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
                    startDateTime = LocalDateTime.parse(startDate, formatter);
                    endDateTime = LocalDateTime.parse(endDate, formatter);
                    log.info("--------------------------");
                    log.info("searchText  = " + searchText);
                    log.info("startDate  = " + startDate);
                    log.info("endDate  = " + endDate);
                    log.info("--------------------------");
                }
            }catch (Exception e){
                e.printStackTrace();
            }
        }
        if(searchText != ""){
            if("DstMRN".equals(searchName))
                p = clientResponseRepository.findByRegDateBetweenAndDstMrnContaining(startDateTime,endDateTime,searchText,pageable);
            else
                p = clientResponseRepository.findByRegDateBetweenAndSrcMrnContaining(startDateTime,endDateTime,searchText,pageable);

        }else{
            p = clientResponseRepository.findByRegDateBetween(startDateTime,endDateTime,pageable);
        }

        //문제 발생 : "|" 과 같은 특수문자가 request 상에 넘어올 때 내장형 톰캣에서 오류 발생
        //Tomcat 상위 버전에서 발생한 문제로 인해 Undertow로 변경함
        VuePage<ClientResponse> vuepage = new VuePage(p.getContent(), pageable, p.getTotalElements(), url);

        //  size <-- per_page=10
        log.error("offset : {}",pageable.getOffset());
        log.error("pageNumber : {}",pageable.getPageNumber());
        log.error("pagesize : {}",pageable.getPageSize());
        log.error("sort : {}",pageable.getSort());

        return vuepage;
    }

    @CrossOrigin(maxAge = 3600)
    @RequestMapping("/queuelist")
    @ResponseBody
    public String  getQueueList() throws Exception{
        HttpResponse<String> response = Unirest.get("http://localhost:15672/api/queues")
                .header("authorization", "Basic Z3Vlc3Q6Z3Vlc3Q=")
                .header("cache-control", "no-cache")
                .asString();
        return response.getBody().toString();
    }



    @CrossOrigin(maxAge = 3600)
    @RequestMapping("/svlist")
    @ResponseBody
    public List<String> getSVList() throws Exception{
        return fileService.getSVList();
    }

    @CrossOrigin(maxAge = 3600)
    @RequestMapping("/svfile")
    public String getSVFile(@RequestBody MyFile mcSvFile) throws Exception{
        return fileService.getSVFile(mcSvFile);
    }

    @CrossOrigin
    @RequestMapping("/path")
    @ResponseBody
    public MyHttpResponse httpRequest(@RequestBody MyHttpRequest mcHttpRequest)  throws Exception{
        return serverService.httpRequest(mcHttpRequest);
    }

}
