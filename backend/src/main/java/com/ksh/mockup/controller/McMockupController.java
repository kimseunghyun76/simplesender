package com.ksh.mockup.controller;

import com.ksh.mockup.entity.ClientResponse;
import com.ksh.mockup.entity.MyFile;
import com.ksh.mockup.entity.MyHttpRequest;
import com.ksh.mockup.entity.MyHttpResponse;
import com.ksh.mockup.repository.ClientResponseRepository;
import com.ksh.mockup.repository.VuePage;
import com.ksh.mockup.repository.VuePageable;
import com.ksh.mockup.service.FileService;
import com.ksh.mockup.service.ServerService;
import org.json.simple.JSONObject;
import org.json.simple.JSONArray;
import org.json.simple.parser.ParseException;
import org.json.simple.parser.JSONParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.support.ResourcePatternResolver;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Sort;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.UnsupportedEncodingException;
import java.util.List;



@RestController
public class McMockupController {

    private static final Logger log = LoggerFactory.getLogger(McMockupController.class);

    @Autowired
    ResourcePatternResolver resourceResolver;

    @Autowired
    FileService fileService;

    @Autowired
    ServerService serverService;


    @Value("${server.address}")
    private String serverAddress;

    @Value("${server.port}")
    private String serverPort;


    @RequestMapping("/")
    public ResponseEntity<String> getServiceResult(RequestEntity<String> requestEntity) throws UnsupportedEncodingException {
        return serverService.getServiceResult(requestEntity);
    }

    //This means to get the bean call clientResponseRepository
    //which is auto-generated by Spring, we will use it to handle the data
    @Autowired
    private ClientResponseRepository clientResponseRepository;



    @CrossOrigin(maxAge = 3600)
    @RequestMapping(path="/clientResponseList")
    @ResponseBody()
    public Iterable<ClientResponse> getClientResponseList(
            @RequestParam(value = "page", defaultValue = "1") int page,
            @RequestParam(value = "per_page", defaultValue = "15") int per_page,
            @RequestParam(value = "sort", required=false) String sort,
            @RequestParam(value = "filter", required=false) String filter) {

        String url ="http://" + serverAddress + ":" +serverPort +"/clientResponseList";
        Sort s = null;
        String properties = "";
        String direction = "";

        if(sort != null && sort.lastIndexOf("|") >  -1){
            properties = sort.split("\\|")[0];
            direction = sort.split("\\|")[1];
            log.info(properties);
            log.info(direction);
            if(direction.equals("desc")){
                s = new Sort(Sort.Direction.DESC,properties);
            }else{
                s = new Sort(Sort.Direction.ASC,properties);
            }
        }
        //VUE에서는 0 부터 시작하지 않고, 1부터 시작한다.
        // 따라서 page 값에서 -1 을 해서 추가해야한다.
        page= page-1;
        VuePageable pageable = new VuePageable(page, per_page, s);
        Page p = null;

        JSONParser parser = new JSONParser();
        String findFilter = "";
        if(filter != null){
            try{
                Object obj = parser.parse("["+filter+"]");
                JSONArray array = (JSONArray)obj;
                JSONObject filterObj = (JSONObject)array.get(0);
                if(filterObj.get("filter") != null)
                  findFilter = filterObj.get("filter").toString();
            }catch (Exception e){
                e.printStackTrace();
            }
        }
        if(findFilter != ""){
            log.error(findFilter);
            p = clientResponseRepository.findByDstMrnContainingOrSrcMrnContaining(findFilter,findFilter ,pageable);
        }else{
            p = clientResponseRepository.findAll(pageable);
        }

        //문제 발생 : "|" 과 같은 특수문자가 request 상에 넘어올 때 내장형 톰캣에서 오류 발생
        //Tomcat 상위 버전에서 발생한 문제로 인해 Undertow로 변경함
        VuePage<ClientResponse> vuepage = new VuePage(p.getContent(), pageable, p.getTotalElements(), url);

        //  size <-- per_page=10
        log.error("offset : {}",pageable.getOffset());
        log.error("pageNumber : {}",pageable.getPageNumber());
        log.error("pagesize : {}",pageable.getPageSize());
        log.error("sort : {}",pageable.getSort());

        return vuepage;
    }

    @CrossOrigin(maxAge = 3600)
    @RequestMapping("/svlist")
    @ResponseBody
    public List<String> getSVList() throws Exception{
        return fileService.getSVList();
    }

    @CrossOrigin(maxAge = 3600)
    @RequestMapping("/svfile")
    public String getSVFile(@RequestBody MyFile mcSvFile) throws Exception{
        return fileService.getSVFile(mcSvFile);
    }

    @CrossOrigin
    @RequestMapping("/path")
    @ResponseBody
    public MyHttpResponse httpRequest(@RequestBody MyHttpRequest mcHttpRequest)  throws Exception{
        return serverService.httpRequest(mcHttpRequest);
    }

}
